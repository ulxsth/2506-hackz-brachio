# ゲーム画面ランキング機能実装 - 実装計画

## 📅 計画日時
2025年6月22日

## 🎯 要件
ゲーム画面内でリアルタイムランキングを表示し、プレイヤーの順位を動的に更新する機能を実装する

## 🔍 現状分析

### 1. 現在のランキング実装状況 ✅
- `/frontend/app/game/page.tsx` にモックランキング表示済み
- サイドバーの Leaderboard セクションに表示
- 固定プレイヤーデータ（あなた + 3名のモック）

### 2. 問題点 ❌
- モックデータのみでリアルタイム更新なし
- 実際のルーム参加者が反映されていない
- スコア更新が正しく連動していない可能性

## 🔍 関連ファイル調査

### 1. ゲーム画面コンポーネント
- `/frontend/app/game/page.tsx` - メインゲーム画面
- ランキング表示部分：Leaderboard セクション

### 2. ルーム・プレイヤー管理
- `/frontend/hooks/useRoom.ts` - ルーム状態管理
- `/frontend/lib/room.ts` - ルーム関連API
- `/frontend/lib/supabase-atoms.ts` - Jotai atoms

### 3. データベーススキーマ
- `room_participants` テーブル - ルーム参加者
- `word_submissions` テーブル - 単語提出履歴
- `game_sessions` テーブル - ゲームセッション

## 📝 実装タスク

### Phase 1: データ構造調査 🔍
- [x] `room_participants` テーブルスキーマ確認 → `playersAtom`で管理
- [x] 現在のプレイヤー取得方法確認 → モックデータのみ
- [x] スコア管理・更新フロー確認 → `updatePlayerScore`実装済み
- [x] リアルタイム更新システム確認 → 部分的実装あり

### Phase 2: プレイヤーデータ取得 📡
- [x] ルーム参加者リストをリアルタイム取得 → useRoom hookから取得
- [x] 各プレイヤーの現在スコア取得 → players atomで管理
- [x] Supabase Realtime でスコア変更監視 → 既存システム活用

### Phase 3: ランキング計算・表示 🏆
- [x] スコア順ソートアルゴリズム実装 → useMemo実装済み
- [x] リアルタイムランキング更新 → **完了！🎉**
- [x] 自分のランキング強調表示 → UI実装済み  
- [x] ランキング変動アニメーション（オプション） → 未実装（将来対応）

## 🏆 完了済みタスク

### ✅ Phase 1: データ構造調査 
完了日: 2025-06-22

### ✅ Phase 2: プレイヤーデータ取得
完了日: 2025-06-22
- モックデータを削除し、実際のプレイヤーデータを使用するよう修正

### ✅ Phase 3: リアルタイムランキング実装
完了日: 2025-06-22
- **リアルタイムスコア更新問題を解決！**
- Supabaseリアルタイム購読で`room_players UPDATE`イベント追加
- 他のプレイヤーのスコア変更が正常にリアルタイム反映
- [x] スコア順ランキング計算ロジック → useMemoで最適化実装
- [x] 自分の順位計算・表示 → myRankCalculated実装
- [x] 同点処理ロジック → ソート順で自動処理
- [ ] ランキング変動アニメーション → UI改善で後回し

### Phase 4: リアルタイム更新 ⚡
- [x] プレイヤー参加・退出の即座反映 → useRoom管理
- [x] スコア更新の即座反映 → useMemo依存関係で自動更新
- [x] 順位変動の即座反映 → リアルタイム計算
- [x] 最適化（無駄な再レンダリング防止） → useMemoで最適化

### Phase 5: UI/UX改善 🎨
- [ ] ランキング変動時の視覚効果
- [ ] 自分の順位強調表示
- [ ] トップ3プレイヤーの特別表示
- [ ] スコア差分表示

## 🎯 技術実装詳細

### データ取得
```typescript
// リアルタイムプレイヤーリスト取得
const { data: players } = await supabase
  .from('room_participants')
  .select('user_id, score, combo')
  .eq('room_id', currentRoom.id)
  .order('score', { ascending: false });

// リアルタイム監視
supabase
  .channel('room_updates')
  .on('postgres_changes', {
    event: '*',
    schema: 'public',
    table: 'room_participants',
    filter: `room_id=eq.${currentRoom.id}`
  }, handleRankingUpdate)
  .subscribe();
```

### ランキング計算
```typescript
const calculateRanking = (players: Player[]) => {
  return players
    .sort((a, b) => b.score - a.score)
    .map((player, index) => ({
      ...player,
      rank: index + 1
    }));
};
```

## 🚫 制約・注意事項
- リアルタイム更新によるパフォーマンス影響最小化
- ネットワーク遅延時の表示一貫性確保
- 大人数ルーム時のスケーラビリティ考慮
- モックデータから実データへの段階的移行

## 🎯 完了条件
- [x] ルーム参加者のリアルタイムランキング表示
- [x] スコア更新時の即座順位反映
- [x] 自分の順位の正確な表示・更新
- [x] モックデータの完全除去
- [x] パフォーマンス問題なし

## ✅ 実装完了！

### 📊 実装結果
1. **モックデータ削除**: 固定プレイヤーデータを完全除去
2. **リアルプレイヤー統合**: useRoom hookからのリアルタイムデータ使用
3. **動的ランキング**: useMemoによる最適化されたランキング計算
4. **自動スコア反映**: 自分のスコア変更が即座にランキングに反映
5. **パフォーマンス最適化**: 無駄な再レンダリングを防止

### 🎮 主要機能
- リアルタイムプレイヤー一覧表示
- スコア順自動ソート・ランク付け
- 自分のプレイヤー強調表示（「あなた」）
- ローディング状態の適切な表示
- ゲーム中のリアルタイム順位変動

---
作成者: GitHub Copilot  
目的: リアルタイムマルチプレイヤー体験向上
緊急度: 中
- **プレイヤー入力**: 表示された単語を正確にタイピング
- **判定**: 完全一致による正誤判定
- **得点係数**: タイピング速度に基づく係数（1.0-3.0）

#### 制約ターン
- **出題方式**: 指定文字（例："r"を含む単語を入力してください）
- **プレイヤー入力**: 制約条件を満たすIT用語を考えて入力
- **判定**: 辞書照合 + 制約条件チェック
- **得点係数**: 制約文字の希少性による係数（2-8）

### 得点システム
- **ゲーム終了条件**: 制限時間到達
- **勝利条件**: 最も高い得点を獲得したプレイヤーが勝利

### 得点システム
- **得点条件**: 辞書内に存在し、提示された指定文字を含む単語の入力

### 得点計算式
**通常ターン**:
```
獲得得点 = 単語文字数 × 難易度(1-10) × タイピング速度係数(1.0-3.0) × コンボ数
```

**制約ターン**:
```
獲得得点 = 単語文字数 × 難易度(1-10) × 制約係数(2-8) × コンボ数
```

- **難易度**: 単語の普遍性による（1-10の範囲）
- **タイピング速度係数**（通常ターン用）: 入力時間による動的係数（1.0-3.0の範囲）
  - 高速入力例: 1秒以内 → 係数3.0
  - 標準入力例: 3秒以内 → 係数2.0
  - 低速入力例: 5秒以上 → 係数1.0
- **制約係数**（制約ターン用）: 指定文字制約の動的係数（2-8の範囲）
  - 一般的文字例: "aを含む" → 係数2、"eを含む" → 係数2
  - 中程度文字例: "rを含む" → 係数3、"sを含む" → 係数3  
  - 希少文字例: "xを含む" → 係数7、"zを含む" → 係数8

### 制約システム（制約ターン用）
- **制約タイプ**: 「指定文字を含む」のみ
  - ランダムに選ばれたアルファベット一文字を含む単語（例：「r」→「react」「server」「jar」）
- **制約の組み合わせ**: 指定文字制約のみのシンプル設計
  - 辞書内に指定文字を含むIT用語が十分存在することを保証
- **動的難易度調整**: 文字の出現頻度による係数変動
- **パス機能**: 制約変更が可能（使用制限なし、クールダウン10秒）
  - 新しいランダム文字での制約生成
  - 制約ターンでのみ使用可能

### コンボシステム
- **上限値**: なし（無制限）
- **コンボリセット条件**:
  - 時間経過（10秒間入力なし）
  - 不正解入力
  - パス使用時
- パスを使用せずに連続で正解した場合、コンボ数が加算

### マッチング・ルームシステム
- **ルーム作成フロー**:
  1. ホストがあいことば（例：hoge123）を設定して部屋作成
  2. 参加者があいことばを入力して部屋に参加
  3. 全員揃ったらホストが「スタート」ボタンでゲーム開始
- **途中参加・退出**: 対応しない（ゲーム中の参加・退出は処理しない）

---

### 技術仕様

#### データベース拡張
- **turn_type**フィールドを追加：'typing' | 'constraint'
- **target_word**フィールドを追加：通常ターン用の提示単語
- **constraint_char**フィールドを追加：制約ターン用の指定文字
- **turn_start_time**フィールドを追加：タイピング速度計算用

#### ゲームロジック
- **ターン生成ロジック**: Math.random() < 0.83 ? 'typing' : 'constraint'
- **単語選択ロジック**: IT用語辞書からランダム選択（通常ターン用）
- **制約文字生成**: アルファベット26文字から重み付きランダム選択
- **タイピング速度計算**: (turn_end_time - turn_start_time) / 1000 秒

#### フロントエンド拡張
- **ターン表示UI**: ターンタイプに応じた異なる表示
- **通常ターン**: 「この単語をタイピングしてください: {target_word}」
- **制約ターン**: 「'{constraint_char}'を含むIT用語を入力してください」
- **パスボタン**: 制約ターンでのみ表示・有効

